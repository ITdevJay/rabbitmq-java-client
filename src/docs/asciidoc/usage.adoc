:test-examples: ../../test/java/com/rabbitmq/docs


[[overview]]
== API Overview

This section covers https://github.com/rabbitmq/rabbitmq-java-client/[RabbitMQ Java client] and its public API.
It assumes that the reader is familiar with https://rabbitmq.com/getstarted.html[the basics icon:external-link[]^].

The client API exposes key entities in the https://rabbitmq.com/tutorials/amqp-concepts.html[AMQP 0-9-1 protocol model], with additional abstractions for ease of use.

RabbitMQ Java client uses `com.rabbitmq.client` as its top-level package.
The key classes and interfaces are:

* `Channel`: represents an AMQP 0-9-1 channel, and provides most of the operations (protocol methods).
* `Connection`: represents an AMQP 0-9-1 connection.
* `ConnectionFactory`: constructs `Connection` instances.
* `Consumer`: represents a message consumer.
* `DefaultConsumer`: commonly used base class for consumers.
* `BasicProperties`: message properties (metadata).
* `BasicProperties.Builder`: builder for `BasicProperties`.

Protocol operations are available through the `Channel` interface.
`Connection` is used to open channels, register connection lifecycle event handlers, and close connections that are no longer needed.
`Connection`s are instantiated through `ConnectionFactory`, which is how you configure various connection settings, such as the vhost or username.

== Imports

The interfaces and classes of the AMQP Java client are located in the `com.rabbitmq.client` package.
You can import the types one by one or use a wildcard import:

.Core API imports
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=imports]
--------

[[connections-and-channels]]
== Connections and Channels

The core API classes are `Connection` and `Channel`, representing an AMQP 0-9-1 connection and  channel, respectively.
The next sections show how to use them.

[[connecting]]
== Connecting to RabbitMQ

The following code connects to a RabbitMQ node using the given parameters (host name, port number, etc):

.Connection to a RabbitMQ node
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connecting]
--------
<1> `guest`/`guest` by default, limited to localhost connections


All of these parameters have sensible defaults for a RabbitMQ node running locally.

The default value for a property will be used if the property remains unassigned prior to creating a connection:

[%header,cols=2*]
|===
|Property
|Default Value

|Username
|`guest`

|Password
|`guest`

|Virtual host
|`/`

|Hostname
|`localhost`

|Port
|5672 for regular connections, 5671 for https://rabbitmq.com/ssl.html[connections that use TLS]
|===

[[uri]]
=== Connecting Using a URI

Alternatively, https://rabbitmq.com/uri-spec.html[URIs] may be used:

.Connection with a URI
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=uri]
--------

Successful and unsuccessful client connection events can be https://rabbitmq.com/logging.html[observed in server node logs].

Note that https://rabbitmq.com/access-control.html[user guest can only connect from localhost] by default.
This is to limit well-known credential use in production systems.

Application developers can <<client-provided-names,assign a custom name to a connection>>.
If set,  the name will be mentioned in RabbitMQ node logs as well as https://rabbitmq.com/management.html[management UI].

The `Connection` interface can then be used to open a channel:

.Opening a channel
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=open-channel]
--------

The channel can now be used to send and receive messages, as described in subsequent sections.

[[endpoints-list]]
=== Using Lists of Endpoints

It is possible to specify a list of endpoints to use when connecting.
The first reachable endpoint will be used.
In case of <<recovery.adoc#recovery,connection failures>>, using a list of endpoints makes it possible for the application to connect to a different node if the original one is down.

To use multiple endpoints, provide a list of ``Address``es to `ConnectionFactory#newConnection`.
An `Address` represents a hostname and port pair.

.Using multiple endpoints
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=endpoint-list]
--------

In the code snippet above, the library will attempt to connect to `hostname1:port1`, and if that fails to `hostname2:port2`.
The connection returned is the first in the array that succeeds (without throwing
`IOException`).
This is entirely equivalent to repeatedly setting host and port on a factory, calling `factory.newConnection()` each time, until one of them succeeds.

If an `ExecutorService` is provided as well (using the form `factory.newConnection(es, addrArr)`) the thread pool is associated with the (first) successful connection.

If you want more control over the host to connect to, see
<<service-discovery-with-address-resolver,the support for service discovery>>.

[[disconnecting]]
== Disconnecting from RabbitMQ

To disconnect, simply close the channel and the connection:

.Closing a channel and a connection
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=disconnecting]
--------
Note that closing the channel may be considered good practice, but is not strictly necessary here - it will be done automatically anyway when the underlying connection is closed.

Client disconnection events can be https://rabbitmq.com/networking.html#logging[observed in server node logs].

[[connection-and-channel-lifespan]]
== Connection and Channel Lifespan

Client https://rabbitmq.com/connections.html[connections] are meant to be long-lived.
The underlying protocol is designed and optimized for long-running connections.
That means that opening a new connection per operation, e.g. a message published, is unnecessary and strongly discouraged as it will introduce a lot of network roundtrips and overhead.

https://rabbitmq.com/channels.html[Channels] are also meant to be long-lived but since many recoverable protocol errors will result in channel closure, channel lifespan could be shorter than that of its connection.
Closing and opening new channels per operation is usually unnecessary but can be appropriate.
When in doubt, consider reusing channels first.

https://rabbitmq.com/channels.html#error-handling[Channel-level exceptions] such as attempts to consume from a queue that does not exist will result in channel closure.
A closed channel can no longer be used and will not receive any more events from the server (such as message deliveries).
Channel-level exceptions will be logged by RabbitMQ and will initiate a shutdown sequence for the channel (see below).

[[client-provided-names]]
== Client-Provided Connection Name

RabbitMQ nodes have a limited amount of information about their clients:

* their TCP endpoint (source IP address and port)
* the credentials used

This information alone can make identifying applications and instances problematic, in particular when credentials can be shared and clients connect over a load balancer but https://rabbitmq.com/networking.html#proxy-protocol[Proxy protocol] cannot be enabled.

To make it easier to identify clients in https://rabbitmq.com/logging.html[server logs] and https://rabbitmq.com/management.html[management UI], AMQP 0-9-1 client connections, including the RabbitMQ Java client, can provide a custom identifier.
If set, the identifier will be mentioned in log entries and management UI.
The identifier is known as the *client-provided connection name*.
The name can be used to identify an application or a specific component within an application.
The name is optional; however, developers are strongly encouraged to provide one as it would significantly simplify certain operational tasks.

RabbitMQ Java client's https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/ConnectionFactory.html#newConnection(java.util.concurrent.ExecutorService,com.rabbitmq.client.Address%5B%5D,java.lang.String)[`ConnectionFactory#newConnection` method overrides] accept a client-provided connection name.
Here's a modified connection example used above which provides such a name:

.Set a connection name
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=client-provided-name]
--------
<1> Provide a custom connection name

[[exchanges-and-queues]]
== Using Exchanges and Queues

Client applications work with exchanges and https://rabbitmq.com/queues.html[queues], the high-level https://rabbitmq.com/tutorials/amqp-concepts.html[building blocks of the protocol].
These must be declared before they can be used.
Declaring either type of object simply ensures that one of that name exists, creating it if necessary.

Continuing the previous example, the following code declares an exchange and a https://rabbitmq.com/queues.html#server-named-queues[server-named queue], then binds them together.

[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=declare-exclusive-queue]
--------

This will actively declare the following objects, both of which can be customised by using additional parameters.
Here neither of them have any special arguments.

* a durable, non-autodelete exchange of "direct" type
* a non-durable, exclusive, autodelete queue with a generated name

The above function calls then bind the queue to the exchange with the
given routing key.

Note that this would be a typical way to declare a queue when only one client wants to work with it: it doesn't need a well-known name, no other client can use it (exclusive) and will be cleaned up automatically (autodelete).
If several clients want to share a queue with a well-known name, this code would be appropriate:

[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=declare-queue]
--------

This will actively declare:

* a durable, non-autodelete exchange of "direct" type
* a durable, non-exclusive, non-autodelete queue with a well-known name

Many `Channel` API methods are overloaded.
These convenient short forms of `exchangeDeclare`, `queueDeclare` and `queueBind` use sensible defaults.
There are also longer forms with more parameters, to let you override these defaults as necessary, giving full control where needed.

This "short form, long form" pattern is used throughout the client API uses.

[[passive-declaration]]
=== Passive Declaration

Queues and exchanges can be declared "passively".
A passive declare simply checks that the entity with the provided name exists.
If it does, the operation is a no-op.
For queues successful passive declares will return the same information as non-passive ones, namely the number of consumers and messages in https://rabbitmq.com/confirms.html[ready state] in the queue.

If the entity does not exist, the operation fails with a channel level exception.
The channel cannot be used after that.
A new channel should be opened.
It is common to use one-off (temporary) channels for passive declarations.

`Channel#queueDeclarePassive` and `Channel#exchangeDeclarePassive` are the methods used for passive declaration.
The following example demonstrates `Channel#queueDeclarePassive`:

.Passive declaration
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=declare-passive]
--------
<1> Return the number of messages in Ready state in the queue
<2> Return the number of consumers the queue has

``Channel#exchangeDeclarePassive``'s return value contains no useful information.
Therefore if the method returns and no channel exceptions occurs, it means that the exchange does exist.

[[nowait-methods]]
=== Operations with Optional Responses

Some common operations also have a "no wait" version which won't wait for server response.
For example, to declare a queue and instruct the server to not send any response, use:

.Queue declaration with "no wait"
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=declare-no-wait]
--------

The "no wait" versions are more efficient but offer lower safety guarantees, e.g. they are more dependent on the https://rabbitmq.com/heartbeats.html[heartbeat mechanism] for detection of failed operations.
When in doubt, start with the standard version.
The "no wait" versions are only needed in scenarios with high topology (queue, binding) churn.

[[deleting-entities]]
=== Deleting Entities and Purging Messages

A queue or exchange can be explicitly deleted:

[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=delete]
--------

It is possible to delete a queue only if it is empty:

[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=delete-empty]
--------

or if it is not used (does not have any consumers):

[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=delete-unused]
--------

A queue can be purged (all of its messages deleted):

[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=purge]
--------

[[publishing]]
== Publishing Messages

To publish a message to an exchange, use `Channel.basicPublish` as follows:

.Publishing a message to an exchange
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=publish]
--------

For fine control, use overloaded variants to specify the `mandatory` flag, or send messages with pre-set message properties (see the https://rabbitmq.com/publishers.html[Publishers guide] for details):

.Publishing a message with the mandatory flag and pre-set properties
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=publish-mandatory]
--------

This sends a message with delivery mode 2 (persistent), priority 1 and content-type "text/plain".

Use the `Builder` class to build a message properties object with as many properties as needed, for example:

.Using the property builder
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=publish-builder]
--------

This example publishes a message with custom headers:

.Setting custom headers
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=publish-headers]
--------

This example publishes a message with expiration:

.Setting expiration
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=publish-expiration]
--------

This is just a brief set of examples that does not demonstrate every supported property.

Note that `BasicProperties` is an inner class of an outer class, `AMQP`.

Invocations of `Channel#basicPublish` will eventually block if a https://www.rabbitmq.com/alarms.html[resource-driven alarm] is in effect.

[[concurrency]]
== Channels and Concurrency Considerations (Thread Safety)

Sharing `Channel` instances between threads should be avoided.
Applications should be using a `Channel` per thread instead of sharing the same `Channel` across multiple threads.

While some operations on channels are safe to invoke concurrently, some are not and will result in incorrect frame interleaving on the wire, double acknowledgements and so on.

Concurrent publishing on a shared channel can result in incorrect frame interleaving on the wire, triggering a connection-level protocol exception and immediate connection closure by the broker.
It therefore requires explicit synchronization in application code (`Channel#basicPublish` must be invoked in a critical section).
Sharing channels between threads will also interfere with https//rabbitmq.com/confirms.html[Publisher
Confirms].
Concurrent publishing on a shared channel is best avoided entirely, e.g. by using a channel per thread.

It is possible to use channel pooling to avoid concurrent publishing on a shared channel: once a thread is done working with a channel, it returns it to the pool, making the channel available for another thread.
Channel pooling can be thought of as a specific synchronization solution.
It is recommended that an existing pooling library is used instead of a homegrown solution.
For example, https://projects.spring.io/spring-amqp/[Spring AMQP] which comes with a ready-to-use channel pooling feature.

Channels consume resources and in most cases applications very rarely need more than a few hundreds open channels in the same JVM process.
If we assume that the application has a thread for each channel (as channel shouldn't be used concurrently), thousands of threads for a single JVM is already a fair amount of overhead that likely can be avoided.
Moreover a few fast publishers can easily saturate a network interface and a broker node: publishing involves less work than routing, storing and delivering messages.

A classic anti-pattern to be avoided is opening a channel for each published message.
Channels are supposed to be reasonably long-lived and opening a new one is a network round-trip which makes this pattern extremely inefficient.

Consuming in one thread and publishing in another thread on a shared channel can be safe.

Server-pushed deliveries (see the section below) are dispatched concurrently with a guarantee that per-channel ordering is preserved.
The dispatch mechanism uses a https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html[`java.util.concurrent.ExecutorService`], one per connection.
It is possible to provide a custom executor that will be shared by all connections produced by a single `ConnectionFactory` using the `ConnectionFactory#setSharedExecutor` setter.

When https://rabbitmq.com/confirms.html[manual acknowledgements] are used, it is important to consider what thread does the acknowledgement.
If it's different from the thread that received the delivery (e.g. `Consumer#handleDelivery` delegated delivery handling to a different thread), acknowledging with the `multiple` parameter set to `true` is unsafe and will result in double-acknowledgements, and therefore a channel-level protocol exception that closes the channel.
Acknowledging a single message at a time can be safe.

[[consuming]]
== Receiving Messages by Subscription ("Push API")

The most efficient way to receive messages is to set up a subscription using the `Consumer` interface.
The messages will then be delivered automatically as they arrive, rather than having to be explicitly requested.

When calling the API methods relating to ``Consumer``s, individual subscriptions are always referred to by their consumer tags.
A consumer tag is a consumer identifier which can be either client- or server-generated.
To let RabbitMQ generate a node-wide unique tag, use a `Channel#basicConsume` override that doesn't take a consumer tag argument or pass an empty string for consumer tag and use the value returned by `Channel#basicConsume`.
Consumer tags are used to cancel consumers.

Distinct `Consumer` instances must have distinct consumer tags.
Duplicate consumer tags on a connection is strongly discouraged and can lead to issues with <<recovery.adoc#connection-recovery,automatic connection recovery>> and confusing monitoring data when consumers are monitored.

The easiest way to implement a `Consumer` is to subclass the convenience class `DefaultConsumer`.
An object of this subclass can be passed on a `basicConsume` call to set up the subscription:

.Using the `DefaultConsumer` convenience class
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=default-consumer]
--------

Here, since we specified `autoAck = false`, it is necessary to acknowledge messages delivered to the `Consumer`, most conveniently done in the `handleDelivery` method, as illustrated.

More sophisticated ``Consumer``s will need to override further methods.
In particular, `handleShutdownSignal` is called when channels and connections close, and `handleConsumeOk` is passed the consumer tag before any other callbacks to that `Consumer` are called.

``Consumer``s can also implement the `handleCancelOk` and `handleCancel` methods to be notified of explicit and implicit cancellations, respectively.

You can explicitly cancel a particular `Consumer` with `Channel.basicCancel`, passing the consumer tag:

.Cancelling a consumer
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=consumer-cancel]
--------

Just like with publishers, it is important to consider concurrency hazard safety for consumers.

Callbacks to ``Consumer``s are dispatched in a thread pool separate from the thread that instantiated its `Channel`.
This means that ``Consumer``s can safely call blocking methods on the `Connection` or `Channel`, such as `Channel#queueDeclare` or `Channel#basicCancel`.

Each `Channel` will dispatch all deliveries to its `Consumer` handler methods on the thread pool in order they were sent by RabbitMQ.
Ordering of deliveries between channels is not guaranteed: those deliveries can be dispatched in parallel.

For the most common use case of one `Consumer` per `Channel`, this means ``Consumer``s do not hold up other ``Consumer``s.
With multiple ``Consumer``s per `Channel` be aware that a long-running `Consumer` may hold up dispatch of callbacks to other ``Consumer``s on that `Channel`.

Please refer to the <<concurrency,Concurrency Considerations>> (Thread Safety) section for other topics related to concurrency and concurrency hazard safety.

[[getting]]
== Retrieving Individual Messages ("Pull API")

It is also possible to retrieve individual messages on demand ("pull API" a.k.a. polling).
This approach to consumption is highly inefficient as it is effectively polling and applications repeatedly have to ask for results even if the vast majority of the requests yield no results.
Therefore using this approach *is highly discouraged*.

To "pull" a message, use the `Channel.basicGet` method.
The returned value is an instance of `GetResponse`, from which the header information (properties) and message body can be extracted:

.Pulling a message with `basicGet`
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=basic-get]
--------

Since this example uses https://rabbitmq.com/confirms.html[manual acknowledgements] (the `autoAck = false` above), you must also call `Channel.basicAck` to acknowledge that you have successfully received the message:

.Acknowledging the message
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=basic-get-ack]
--------
<1> Acknowledge receipt of the message

[[returning]]
== Handling unroutable messages

If a message is published with the "mandatory" flags set, but cannot be routed, the broker will return it to the sending client (via an `AMQP.Basic.Return` command).

To be notified of such returns, clients can implement the `ReturnListener` interface and call `Channel.addReturnListener`.
If the client has not configured a return listener for a particular channel, then the associated returned messages will be silently dropped.

.Registering a `ReturnListener`
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=returning]
--------

A return listener will be called, for example, if the client publishes a message with the "mandatory" flag set to an exchange of "direct" type which is not bound to a queue.

[[shutdown]]
== Shutdown Protocol

[[shutdown-overview]]
=== Overview of the Client Shutdown Process

The AMQP 0-9-1 connection and channel share the same general approach to managing network failure, internal failure, and explicit local shutdown.

The AMQP 0-9-1 connection and channel have the following lifecycle states:

* `open`: the object is ready to use
* `closing`: the object has been explicitly notified to shut down locally, has issued a shutdown request to any supporting lower-layer objects, and is waiting for their shutdown procedures to complete
* `closed`: the object has received all shutdown-complete notification(s) from any lower-layer objects, and as a consequence has shut itself down

Those objects always end up in the closed state, regardless of the reason that caused the closure, like an application request, an internal client library failure, a remote network request or network failure.

The connection and channel objects possess the following shutdown-related methods:

* `addShutdownListener(ShutdownListener listener)` and `removeShutdownListener(ShutdownListener listener)`, to manage any listeners, which will be fired when the object transitions to`closed` state.
Note that, adding a `ShutdownListener` to an object that is already closed will fire the listener immediately
* `getCloseReason()`, to allow the investigation of what was the reason of the object's shutdown
* `isOpen()`, useful for testing whether the object is in an open state
* `close(int closeCode, String closeMessage)`, to explicitly notify the object to shut down

Simple usage of listeners would look like:

.Registering a `ShutdownListener`
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=shutdown-listener]
--------

[[shutdown-cause]]
=== Information about the circumstances of a shutdown

One can retrieve the `ShutdownSignalException`, which contains all the information available about the close reason, either by explicitly calling the `getCloseReason()`method or by using the `cause` parameter in the `service(ShutdownSignalException cause)` method of the `ShutdownListener` class.

The `ShutdownSignalException` class provides methods to analyze the reason of the shutdown.
By calling the `isHardError()` method we get information whether it was a connection or a channel error, and `getReason()` returns information about the cause, in the form an AMQP method - either `AMQP.Channel.Close` or `AMQP.Connection.Close` (or null if the cause was some exception in the library, such as a network communication failure, in which case that exception can be retrieved with `getCause()`).

.Getting shutdown information
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=shutdown-cause]
--------

[[shutdown-atomicity]]
=== Atomicity and use of the `isOpen()` method

Use of the `isOpen()` method of channel and connection objects is not recommended for production code, because the value returned by the method is dependent on the existence of the shutdown cause.
The following code illustrates the possibility of race conditions:

.Avoid using `isOpen()` in production code
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=shutdown-atomicity-broken]
--------

Instead, we should normally ignore such checking, and simply attempt the action desired.
If during the execution of the code the channel of the connection is closed, a `ShutdownSignalException` will be thrown indicating that the object is in an invalid state.
We should also catch for `IOException` caused either by `SocketException`, when broker closes the connection unexpectedly, or`ShutdownSignalException`, when broker initiated clean close.

.Catch exceptions to handle shutdown
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=shutdown-atomicity-valid]
--------

[[advanced-connection]]
== Advanced Connection Options

[[consumer-thread-pool]]
=== Consumer Operation Thread Pool

`Consumer` threads (see <<consuming,Receiving>>) are automatically allocated in a new `ExecutorService` thread pool by default.
If greater control is required supply an `ExecutorService` on the `newConnection()` method, so that this pool of threads is used instead.
Here is an example where a larger thread pool is supplied than is normally allocated:

.Using a custom thread pool for consumer operations
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=consumer-thread-pool]
--------

Both `Executors` and `ExecutorService` classes are in the `java.util.concurrent` package.

When the connection is closed a default `ExecutorService` will be `shutdown()`, but a user-supplied `ExecutorService` (like `es` above) will _not_ be `shutdown()`.
Clients that supply a custom `ExecutorService` must ensure it is shutdown eventually (by calling its `shutdown()` method), or else the pool's threads may prevent JVM termination.

The same executor service may be shared between multiple connections, or serially re-used on re-connection but it cannot be used after it is `shutdown()`.

Use of this feature should only be considered if there is evidence that there is a severe bottleneck in the processing of `Consumer` callbacks.
If there are no `Consumer` callbacks executed, or very few, the default allocation is more than sufficient.
The overhead is initially minimal and the total thread resources allocated are bounded, even if a burst of consumer activity may occasionally occur.

[[service-discovery-with-address-resolver]]
=== Service discovery with the AddressResolver interface

It is possible to use an implementation of `AddressResolver` to change the endpoint resolution algorithm used at connection time:

.Using an `AddressResolver` when opening a connection
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=address-resolver]
--------

The `AddressResolver` interface is like the following:

.`AddressResolver` interface
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=address-resolver-interface]
--------

Just like with <<usage.adoc#endpoints-list,a list of endpoints>>, the first `Address` returned will be tried first, then the second if the client fails to connect to the first, and so on.

If an `ExecutorService` is provided as well (using the form `factory.newConnection(es, addressResolver)`) the thread pool is associated with the (first) successful connection.

The `AddressResolver` is the perfect place to implement custom service discovery logic, which is especially useful in a dynamic infrastructure. Combined with <<recovery.adoc#recovery,automatic recovery>>, the client can automatically connect to nodes that weren't even up when it was first started.
Affinity and load balancing are other scenarios where a custom `AddressResolver` could be useful.

The Java client ships with the following implementations (see the javadoc for details):

* `DnsRecordIpAddressResolver`: given the name of a host, returns its IP addresses (resolution against
the platform DNS server).
This can be useful for simple DNS-based load balancing or failover.
* `DnsSrvRecordAddressResolver`: given the name of a service, returns hostname/port pairs.
The search is implemented as a DNS SRV request.
This can be useful when using a service registry like https://www.consul.io/[HashiCorp Consul].

[[heartbeats-timeout]]
=== Heartbeat Timeout

See the https://rabbitmq.com/heartbeats.html[Heartbeats guide] for more information about heartbeats and how to configure them in the Java client.

[[thread-factories]]
=== Custom Thread Factories

Environments such as Google App Engine (GAE) can https://developers.google.com/appengine/docs/java/#Java_The_sandbox[restrict direct thread instantiation].
To use RabbitMQ Java client in such environments, it's necessary to configure a custom `ThreadFactory` that uses an appropriate method to instantiate threads, e.g. GAE's `ThreadManager`.

Below is an example for Google App Engine:

.Setting a custom `ThreadFactory`
[source,java,indent=0]
--------
import com.google.appengine.api.ThreadManager;

ConnectionFactory cf = new ConnectionFactory();
cf.setThreadFactory(ThreadManager.backgroundThreadFactory());
--------

[[java-nio]]
=== Support for Java non-blocking IO

Version 4.0 of the Java client brings support for Java non-blocking IO (a.k.a Java NIO).
NIO isn't supposed to be faster than blocking IO, it simply allows to control resources (in this case, threads) more easily.

With the default blocking IO mode, each connection uses a thread to read from the network socket.
With the NIO mode, you can control the number of threads that read and write from/to the network socket.

Use the NIO mode if your Java process uses many connections (dozens or hundreds).
You should use fewer threads than with the default blocking mode.
With the appropriate number of threads set, you shouldn't experience any decrease in performance, especially if the connections are not so busy.

NIO must be explicitly activated:

.Activating NIO
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=nio-on]
--------

The NIO mode can be configured through the `NioParams` class:

.Configuring NIO
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=nio-params]
--------

The NIO mode uses reasonable defaults, but you may need to change them according to your own workload.
Some of the settings are: the total number of IO threads used, the size of buffers, a service executor to use for the IO loops, parameters for the in-memory write queue (write requests are enqueued before being sent on the network).
Please read the Javadoc for details and defaults.

